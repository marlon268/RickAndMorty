{"version":3,"sources":["context/ThemeContext.js","components/Header.jsx","components/Search.jsx","hooks/useCharacters.js","components/Characters.jsx","App.js","reportWebVitals.js","index.js"],"names":["ThemeContext","React","createContext","ThemeContextProvider","children","useState","theme","setTheme","Provider","value","Header","handleClick","useContext","className","type","onClick","Search","search","searchInput","handleSearch","ref","onChange","placeholder","useCharacters","url","characters","setCharacters","useEffect","fetch","then","response","json","data","results","initialState","favorites","favoriteReducer","state","action","find","item","id","payload","filter","items","Characters","useReducer","dispatch","setSearch","useRef","useCallback","current","filteredUsers","useMemo","user","name","toLowerCase","includes","length","map","favorite","src","image","alt","character","species","status","origin","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.1720a74f.chunk.js","sourcesContent":["import React, { useState } from 'react'\n\nconst ThemeContext = React.createContext({});\n\nexport function ThemeContextProvider({ children }) {\n    const [theme, setTheme] = useState(true);\n\n    return(\n        <ThemeContext.Provider value={{ theme, setTheme}}>\n            {children}\n        </ThemeContext.Provider>\n    )\n}\n\nexport default ThemeContext;","import { useContext } from \"react\";\nimport ThemeContext from \"../context/ThemeContext.js\";\nimport \"../styles/Header.css\";\n\nconst Header = ({ handleClick }) => {\n  const { theme } = useContext(ThemeContext);\n\n  return (\n    <div className=\"Header\">\n      <h1>Rick And Morty</h1>\n      <div className=\"Header-button\">\n        <button\n          type=\"button\"\n          onClick={handleClick}\n          className={!theme ? \"button button-dark\" : \"button button-light\"}\n        >\n          {theme ? \"Dark mode\" : \"Light mode\"}\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\n\nconst Search = ({ search, searchInput, handleSearch}) => {\n  return (\n    <div className=\"Search\">\n      <input\n        className=\"Search-input\"\n        type=\"text\"\n        value={search}\n        ref={searchInput}\n        onChange={handleSearch}\n        placeholder=\"Character search\"\n      />\n    </div>\n  );\n};\n\nexport default Search;\n","import { useState, useEffect } from \"react\";\n\n\nconst useCharacters = (url) => {\n    const [characters, setCharacters] = useState([]);\n    useEffect(() => {\n        fetch(url, {\n            'mode': 'cors',\n\t        'headers': {\n            \t'Access-Control-Allow-Origin': '*',\n        \t}\n        })\n          .then((response) => response.json())\n          .then((data) => setCharacters(data.results));\n      }, [url]);\n      return characters;\n};\n\nexport default useCharacters;","import {\n  useState,\n  useReducer,\n  useMemo,\n  useRef,\n  useCallback,\n} from \"react\";\nimport \"../styles/Characters.css\";\nimport Search from \"./Search\";\nimport useCharacters from \"../hooks/useCharacters.js\"\n\nconst initialState = {\n  favorites: [],\n};\n\nconst API = 'https://rickandmortyapi.com/api/character'\n\nconst favoriteReducer = (state, action) => {\n  switch (action.type) {\n    case \"APP_TO_FAVORITE\":\n      if (state.favorites.find((item) => item.id === action.payload.id)) {\n        return {\n          ...state,\n        };\n      } else {\n        return {\n          ...state,\n          favorites: [...state.favorites, action.payload],\n        };\n      }\n    case \"REMOVE_FAVORITE\":\n      return {\n        ...state,\n        favorites: state.favorites.filter(\n          (items) => items.id !== action.payload\n        ),\n      };\n    default:\n      return state;\n  }\n};\n\nconst Characters = () => {\n  const [favorites, dispatch] = useReducer(favoriteReducer, initialState);\n  const [search, setSearch] = useState(\"\");\n  const searchInput = useRef(null);\n\n\n  // Usamos nuestro custom hook creado con useState y useEfect para separar la\n  // logica de nuestros componentes\n  const characters = useCharacters(API)\n\n  \n  // useEffect se ejecuta despues del primer renderizado de la pagina\n  // es el lugar ideal para hacer un llamada a una api. Este recibe dos\n  // parametros el primero lo que va hacer y el segundo lo que va a estar\n  // escuchando a que cambie para volverse a ejecutar\n  /* useEffect(() => {\n    fetch(\"https://rickandmortyapi.com/api/character/\")\n      .then((response) => response.json())\n      .then((data) => setCharacters(data.results));\n  }, []); */\n\n\n  // Esta funcion nos añade al array de favorites el character que le se pase\n  // por parametro (favorite) y lo añade con la ayuda de el useReducer\n  const handleClickAdd = (favorite) => {\n    dispatch({ type: \"APP_TO_FAVORITE\", payload: favorite });\n  };\n\n\n  // Esta funcion elimina los personajes de favoritos mediante el id\n  // que estos tengan\n  const handleClickRemove = (id) => {\n    dispatch({ type: \"REMOVE_FAVORITE\", payload: id });\n  };\n\n\n\n  // Esta funcion me captura el evento onChange y lo incerta en el estado\n  // search creado anteriormente. Cambios el evento onChange con el uso de\n  // useRef para capturar lo que se escribe en el input de una forma mas amigable\n  // y con menos bugs\n  /* const handleSearch = () => {\n    setSearch(searchInput.current.value);\n  }; */\n\n\n\n  //Cada vez que hacemos un render se vuelve a construir las referencias a las\n  // funciones La solución para este problema es usar useCallback el cual solo\n  // genera una referencia para una función, es decir que memoriza la funcion\n  // a través de la lista de dependencias que mandamos cuando lo generamos,\n  // estamos indicando cuando debe volver a memorizar esa función, es decir cuando \n  // cambien esos valores, esto es útil cuando se transfieren callbacks a \n  //componentes hijos optimizados que dependen de la igualdad de referencia \n  //para evitar renders innecesarios\n  const handleSearch = useCallback(() => {\n    setSearch(searchInput.current.value);\n  }, []);\n\n\n  // Esta funcion toma lo que se a introducido en el search y filtra los characters\n  // por su name que este search tenga incluido ignorando mayusculas\n  /* const filteredUsers = characters.filter((user) => {\n    return user.name.toLowerCase().includes(search.toLowerCase());\n  }); */\n\n\n  // Usamos useMemo para hacer memoizacion, esto nos permite almacenar los resultados de una función\n  // para que, en caso de enviar los mismo argumentos que antes, ésta no haga los cálculos otra\n  // vez sino que devuelva el resultado que registró antes.\n  const filteredUsers = useMemo(\n    () =>\n      characters.filter((user) => {\n        return user.name.toLowerCase().includes(search.toLowerCase());\n      }),\n    [characters, search]\n  );\n\n  return (\n    <main>\n      <h1>{favorites.favorites.length ? \"Favorites\" : \"\"}</h1>\n      <div className=\"Characters-favorites\">\n        {favorites.favorites.map((favorite) => (\n          <div key={favorite.id} className=\"Character-favotire\">\n            <h5>{favorite.name}</h5>\n            <img\n              className=\"favorites\"\n              src={favorite.image}\n              alt={favorite.name}\n            />\n            <button\n              className=\"boton-borrar\"\n              type=\"button\"\n              onClick={() => handleClickRemove(favorite.id)}\n            >\n              X\n            </button>\n          </div>\n        ))}\n      </div>\n\n      <h1>Characters</h1>\n      <Search\n        search={search}\n        searchInput={searchInput}\n        handleSearch={handleSearch}\n      />\n\n      <div className=\"Characters\">\n        {filteredUsers.map((character) => (\n          <div key={character.id} className=\"Characters-container\">\n            <img src={character.image} alt=\"\" />\n            <h1>{character.name}</h1>\n            <h5>Especies: {character.species}</h5>\n            <h5>Status: {character.status}</h5>\n            <h5>Origin: {character.origin.name}</h5>\n            <button\n              type=\"button\"\n              onClick={() => handleClickAdd(character)}\n              className=\"boton-añadir\"\n            >\n              add to Favorites\n            </button>\n          </div>\n        ))}\n      </div>\n    </main>\n  );\n};\n\nexport default Characters;\n\n// En la mayor parte del tiempo no deberias molestarte en optimizar re-renders\n// inncesarios con useMemo. Usalo siempre en cuando el rendering toma una gran\n// cantidad de tiempo como en interacciones muy altas (Graphs/Charts/Animations/etc.)\n","import Header from './components/Header.jsx'\nimport Characters from \"./components/Characters.jsx\"\nimport ThemeContext from \"./context/ThemeContext.js\"\nimport { useContext } from 'react';\n\nfunction App() {\n  const {theme, setTheme} = useContext(ThemeContext);\n  const handleClick = () => {\n    setTheme(!theme)\n  };\n  return (\n    <div className={theme ? 'light-mode contenedor' : 'dark-mode contenedor'}>\n      <Header handleClick={handleClick} />\n      <Characters/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { ThemeContextProvider } from \"./context/ThemeContext.js\"\nimport 'bootstrap/dist/css/bootstrap.min.css'\nimport 'bootstrap-icons/font/bootstrap-icons.css'\n\n//Context nos da un provider donde encapsulamos toda la informacio\n\nReactDOM.render(\n  <React.StrictMode>\n    <ThemeContextProvider>\n      <App />\n    </ThemeContextProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}